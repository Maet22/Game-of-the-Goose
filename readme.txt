This project is a simulation of a purely random game known as the Game of the Goose, in which players progress on a board with 63 squares, the winner being the first to reach the final 63rd square. 

How players go forward is indicated by the number they obtain by throwing two dices. However several specific rules make the game unlinear, full of surprises and inversions of trend. These rules are of two types:

a) rules related to the number obtained by the player when throwing the dices: move directly to 26 if 6+3 (or 3+6) at first throw; move directly to 53 if 5+4 (or 4+5) at first throw

b) rules related to the square reached by the player when adding up initial square to dices number: 6="bridge", player moves to 12; 19="hostel" player gets blocked two turns; 31="well" player gets blocked until substitution in the well by other player; 42="labyrinth" player goes back to 30; 52="prison" player blocked until being freed by other player moving to 52; if player reaches any square where is already an other player, this other player goes back to the square the first player moved from; advance doubled if moving to square with number multiple of 9 (gooses are supposed to stand on this square); if the dices send the player beyond square 63, the player retreats starting 63 by the nb. of squares in excess

Although the Game of the Goose can be played by multiple players (it can even be played alone, even if there is not much point to do so), in this project I limited the number of players to 2 for the sake of simplicity and time management. But I would be able to extend the number of players. 

The game is ready to be played in the "play_here" file, in which is a call to the imported function "goose_game()". This function triggers the game's mechanics and its code is detailed in the "game" file. This function is in turn working with and supported by a class named "Player", whose code is detailed in the "player" file. Two instances of this class, "player1" and "player2", are generated when calling the "goose_game()" function.

Each of the "Player" instances is created with a name chosen by the users/players, whom a prompt invites to do so. The players' progression during the game is monitored using the "positions" list, an instance attribute that contains the successive squares occupied by the players. This list is initialized with a single element, "1", which represents the starting square. 

Afterwards each player's progression (and corresponding incrementation of the "positions" list) is determined by:

a) the class function "move()", mainly, which simulates the throws of the dices by combining two functions that randomly return an integer between 1 and 6, and returns the next position based on the throw of dices and the initial position, which is an input of the "move()" function. The specific rules detailed above are covered by this function, EXCEPT :
          -the rule that is dependent on the latest positions occupied (the "hostel")
          -the rules that are dependent on the latest move of the other player (exchanging squares if a player joins an other, being freed from the "prison" or the "well")

b) as the "move()" function by its design does not consider the succession of positions of the player, let alone the succession of positions of the other player, it is not able, as such (but a future update could see to it), to apply the two types of rules that I just mentionned. I therefore enabled the "game()" function to do it, with a "checklist" to go through before proceeding to a "normal" move, using the "move()" function. 
"game()" was given a specific condition to check in the "positions" instance attribute if the player before playing is starting from the square 19 and if yes complied with the two compulsory turns of hold set by the "hostel" rule. 
It also checks if the player is starting from the "well" or the "prison", in which case it remains blocked unless the other player just joined it. And finally it checks if at its previous turn the other player reached the square the player is departing from: in which case the departure square is changed to the other player's earlier departure square (this check being done IN CASE OF NEGATIVE RESULT AT the check for the "well" and "prison" squares (ELSE), a player who gets liberated restarts from this square or another, and not from the square the "liberator" started from).

This is by this dual process that the set of rules of the game was incorporated into the code. While the all game could be automatically generated from start until someone reaches the square 63, in one go that is to say (as the Game of the Goose is purely a random game with no influence whatsoever from the players), I added into "Player" a class attribute called "plays" which while defined by the player as "x" or "X" at each turn triggers the moving process. This is more fun (relatively) and provides some suspense, more interest to the game and a sense of participating for the players.

This was my first coding project and going again through it many months and more experience later I am aware of its limitations and heavy structure. A key axis of improvement would obviously be to get rid of the dual structure "Player" class/"game()" function and incorporate all into an articulated and swiftly-coded class, maybe a class whose instances would be not single players but a set gathering all the players, potentially more than 2, who knows? To follow carefully then, if you are excited by the possibility of playing on a command line interface version of the Game of the Goose... 
